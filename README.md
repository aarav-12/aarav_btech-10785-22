Task Management System — Kanban Based
Overview

This project is a Kanban-style Task Management System developed as part of an SDE assignment.
The goal was to build a clear, secure, and end-to-end functional system, with special attention to backend structure and authentication, while keeping the frontend lightweight and easy to run locally.

Authenticated users can create and manage their own tasks and move them through three Kanban states: Pending, In Progress, and Completed.

Technology Stack
Backend

Node.js

Express.js

Passport.js (GitHub OAuth)

express-session

dotenv

Frontend

HTML

Vanilla JavaScript

Basic CSS (minimal styling)

Authentication

GitHub OAuth with session-based login

Core Features
Authentication & Access Control

Login using GitHub OAuth

Logout functionality

Session-based authentication

Task routes protected from unauthenticated access

Task Management

Create, view, update, and delete tasks

Tasks are scoped to the logged-in user

Task status updates follow a Kanban workflow

Tasks can be filtered by status

Task Data Model

Each task contains:

title

description

status (pending / in-progress / completed)

due_date

created_at

userId

Kanban Workflow

The frontend renders a Kanban board with three columns:

Pending

In Progress

Completed

Tasks are fetched from the backend and displayed according to their current status.
Instead of implementing drag-and-drop, explicit status action buttons are used to move tasks between columns. This ensures predictable behavior and reliable backend updates within the limited scope of the assignment.

API Reference
Authentication Routes
Method	Endpoint	Purpose
GET	/auth/github	Initiate GitHub login
GET	/auth/github/callback	OAuth callback
GET	/auth/logout	Logout user
Task Routes (Protected)
Method	Endpoint	Purpose
GET	/tasks	Fetch all tasks for logged-in user
GET	/tasks?status=pending	Filter tasks by status
POST	/tasks	Create a new task
PATCH	/tasks/:id/status	Update task status
DELETE	/tasks/:id	Delete a task
Running the Backend
cd backend
npm install
node server.js


The backend server runs on:

http://localhost:5000

Running the Frontend

Open the frontend directly in your browser:

frontend/index.html


Login using GitHub and manage tasks via the Kanban board.

Environment Configuration

Create a .env file inside the backend/ directory using .env.example as a reference.

GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=


Sensitive environment values are intentionally excluded from version control.

Project Structure
backend/
 ├─ server.js
 ├─ .env.example
 ├─ src/
 │  ├─ app.js
 │  ├─ config/
 │  │  └─ passport.js
 │  ├─ middlewares/
 │  │  └─ auth.middleware.js
 │  └─ modules/
 │     ├─ auth/
 │     │  └─ auth.routes.js
 │     └─ tasks/
 │        ├─ task.routes.js
 │        └─ task.controller.js
frontend/
 └─ index.html

Design Choices & Scope

GitHub OAuth was selected instead of a custom signup/login flow to avoid password handling and to keep authentication secure and simple.

In-memory task storage was used to keep the setup lightweight and easy to evaluate. The task structure is intentionally database-ready for future persistence.

Kanban interactions are implemented through controlled status updates rather than drag-and-drop, prioritizing correctness and clarity over UI complexity.

The overall focus was on modular backend design, clean routing, and secure access control.

Error Handling

Invalid input is handled with appropriate 400 responses

Unauthorized access returns 401

Non-existent resources return 404

Git Practices

Incremental commits showing development progress

Meaningful commit messages

No autogenerated or sensitive files committed

Future Enhancements

Database persistence (MongoDB / PostgreSQL)

Drag-and-drop UI for Kanban interactions

User profile update endpoints

Automated tests

Deployment to a hosting platform

Author

Aarav Mithrani

Final Note

This project was implemented end-to-end by me as part of a time-bound assignment.
AI tools were used for guidance and debugging, but the final code structure, logic, and design decisions reflect my own implementation and understanding of backend systems and authentication flows.